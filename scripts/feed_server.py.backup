#!/usr/bin/env python3
"""
Memo-RF Feed Server
Serves a web UI displaying radio transmissions and agent responses from session logs.

Usage:
    python3 scripts/feed_server.py [--port PORT] [--host HOST] [--sessions-dir DIR]

Default: http://0.0.0.0:5050
"""

import json
import os
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from pathlib import Path
import argparse


# HTML UI (inline for simplicity - single file deployment)
HTML_UI = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memo-RF Transmissions Feed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid #333;
            margin-bottom: 30px;
        }
        h1 {
            font-size: 2.5em;
            font-weight: 300;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            font-family: 'Courier New', monospace;
        }
        .subtitle {
            color: #888;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
        }
        .status-indicator.active {
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        button {
            padding: 8px 16px;
            background: #222;
            border: 1px solid #444;
            color: #00ff00;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        button:hover {
            background: #333;
            border-color: #00ff00;
        }
        .feed {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .exchange {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.2s;
        }
        .exchange:hover {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
        }
        .exchange-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a2a2a;
        }
        .session-id {
            font-family: 'Courier New', monospace;
            color: #00ff00;
            font-size: 0.85em;
        }
        .timestamp {
            color: #888;
            font-size: 0.85em;
        }
        .transmission, .response {
            margin-bottom: 10px;
        }
        .label {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .transmission .label {
            color: #4a9eff;
        }
        .response .label {
            color: #ff6b6b;
        }
        .content {
            padding: 12px;
            background: #0f0f0f;
            border-left: 3px solid #333;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        .transmission .content {
            border-left-color: #4a9eff;
        }
        .response .content {
            border-left-color: #ff6b6b;
        }
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        .error {
            background: #2a1515;
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MEMO-RF</h1>
            <div class="subtitle">Radio Transmissions Feed</div>
        </header>

        <div class="controls">
            <div class="status">
                <div class="status-indicator" id="status-indicator"></div>
                <span id="status-text">Connecting...</span>
            </div>
            <button onclick="refreshFeed()">Refresh</button>
        </div>

        <div id="error-container"></div>
        <div class="feed" id="feed"></div>
    </div>

    <script>
        let autoRefreshInterval = null;

        async function loadFeed() {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const feedContainer = document.getElementById('feed');
            const errorContainer = document.getElementById('error-container');

            try {
                statusText.textContent = 'Loading...';
                statusIndicator.classList.remove('active');

                const response = await fetch('/api/feed');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                statusIndicator.classList.add('active');
                statusText.textContent = `Connected â€¢ ${data.exchanges.length} exchanges`;
                errorContainer.innerHTML = '';

                if (data.exchanges.length === 0) {
                    feedContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ“»</div>
                            <h2>No Transmissions Yet</h2>
                            <p>Start Memo-RF to see radio transmissions appear here.</p>
                        </div>
                    `;
                    return;
                }

                feedContainer.innerHTML = data.exchanges.map(exchange => {
                    const date = new Date(exchange.timestamp_ms);
                    const timeStr = date.toLocaleString();

                    return `
                        <div class="exchange">
                            <div class="exchange-header">
                                <span class="session-id">${exchange.session_id}</span>
                                <span class="timestamp">${timeStr}</span>
                            </div>
                            <div class="transmission">
                                <div class="label">Transmission</div>
                                <div class="content">${escapeHtml(exchange.transcript || '(no transcript)')}</div>
                            </div>
                            <div class="response">
                                <div class="label">Response</div>
                                <div class="content">${escapeHtml(exchange.response || '(no response)')}</div>
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                statusIndicator.classList.remove('active');
                statusText.textContent = 'Error';
                errorContainer.innerHTML = `
                    <div class="error">
                        Failed to load feed: ${escapeHtml(error.message)}
                    </div>
                `;
                feedContainer.innerHTML = '';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function refreshFeed() {
            loadFeed();
        }

        // Auto-refresh every 15 seconds
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            autoRefreshInterval = setInterval(loadFeed, 15000);
        }

        // Initial load
        loadFeed();
        startAutoRefresh();
    </script>
</body>
</html>
"""


class FeedHandler(BaseHTTPRequestHandler):
    """HTTP request handler for the feed server."""

    sessions_dir = None  # Set by server
    config_path = None  # Set by server
    config_dir = None   # Set by server

    def do_GET(self):
        """Handle GET requests."""
        parsed_path = urlparse(self.path)

        if parsed_path.path == '/':
            self.serve_html()
        elif parsed_path.path == '/api/feed':
            self.serve_feed_json()
        elif parsed_path.path == '/api/config':
            self.serve_config_json()
        elif parsed_path.path == '/api/personas':
            self.serve_personas_json()
        elif parsed_path.path == '/api/languages':
            self.serve_languages_json()
        else:
            self.send_error(404, "Not Found")

    def do_POST(self):
        """Handle POST requests."""
        parsed_path = urlparse(self.path)

        if parsed_path.path == '/api/config':
            self.update_config()
        else:
            self.send_error(404, "Not Found")

    def serve_html(self):
        """Serve the HTML UI."""
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        self.wfile.write(HTML_UI.encode('utf-8'))

    def serve_feed_json(self):
        """Serve the feed JSON API."""
        try:
            exchanges = self.get_exchanges()

            response = {
                'exchanges': exchanges,
                'total': len(exchanges)
            }

            self.send_response(200)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps(response, indent=2).encode('utf-8'))

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            error_response = {'error': str(e)}
            self.wfile.write(json.dumps(error_response).encode('utf-8'))

    def get_exchanges(self):
        """
        Scan session directories and extract transcript/response exchanges.
        Returns list of exchanges sorted newest first.
        """
        exchanges = []
        sessions_path = Path(self.sessions_dir)

        if not sessions_path.exists():
            return exchanges

        # Get all session directories, sorted by name (session_id) descending
        session_dirs = sorted(
            [d for d in sessions_path.iterdir() if d.is_dir()],
            key=lambda d: d.name,
            reverse=True
        )

        for session_dir in session_dirs:
            session_log_path = session_dir / 'session_log.json'

            if not session_log_path.exists():
                continue

            try:
                with open(session_log_path, 'r', encoding='utf-8') as f:
                    session_data = json.load(f)

                session_id = session_data.get('session_id', session_dir.name)
                events = session_data.get('events', [])

                # Group events into exchanges
                # An exchange is: transcript (or llm_prompt) + llm_response
                i = 0
                while i < len(events):
                    event = events[i]

                    # Look for transcript or llm_prompt
                    if event['event_type'] in ('transcript', 'llm_prompt'):
                        transcript = event['data'].strip()
                        timestamp_ms = event['timestamp_ms']

                        # Look ahead for llm_response
                        response = None
                        for j in range(i + 1, len(events)):
                            if events[j]['event_type'] == 'llm_response':
                                response = events[j]['data'].strip()
                                break
                            # Stop if we hit another transcript (new exchange)
                            if events[j]['event_type'] in ('transcript', 'llm_prompt'):
                                break

                        exchanges.append({
                            'session_id': session_id,
                            'timestamp_ms': timestamp_ms,
                            'transcript': transcript,
                            'response': response
                        })

                    i += 1

            except Exception as e:
                # Skip sessions with errors (e.g., malformed JSON)
                print(f"Warning: Failed to parse {session_log_path}: {e}", file=sys.stderr)
                continue

        return exchanges

    def serve_config_json(self):
        """Serve the current configuration."""
        try:
            if not self.config_path or not Path(self.config_path).exists():
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Config file not found'}).encode('utf-8'))
                return

            with open(self.config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)

            self.send_response(200)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps(config_data, indent=2).encode('utf-8'))

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'error': str(e)}).encode('utf-8'))

    def serve_personas_json(self):
        """Serve the available personas."""
        try:
            if not self.config_dir:
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Config directory not set'}).encode('utf-8'))
                return

            personas_path = Path(self.config_dir) / 'personas.json'
            if not personas_path.exists():
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Personas file not found'}).encode('utf-8'))
                return

            with open(personas_path, 'r', encoding='utf-8') as f:
                personas_data = json.load(f)

            # Convert to list format for easier UI consumption
            personas_list = [
                {
                    'id': key,
                    'name': value.get('name', key),
                    'system_prompt': value.get('system_prompt', '')
                }
                for key, value in personas_data.items()
            ]

            self.send_response(200)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'personas': personas_list}, indent=2).encode('utf-8'))

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'error': str(e)}).encode('utf-8'))

    def serve_languages_json(self):
        """Serve the available languages."""
        try:
            if not self.config_dir:
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Config directory not set'}).encode('utf-8'))
                return

            languages_path = Path(self.config_dir) / 'language_voices.json'
            if not languages_path.exists():
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Languages file not found'}).encode('utf-8'))
                return

            with open(languages_path, 'r', encoding='utf-8') as f:
                languages_data = json.load(f)

            # Convert to list format
            languages_list = [
                {'code': key, 'voice': value}
                for key, value in languages_data.items()
            ]

            self.send_response(200)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'languages': languages_list}, indent=2).encode('utf-8'))

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'error': str(e)}).encode('utf-8'))

    def update_config(self):
        """Update the configuration file."""
        try:
            if not self.config_path or not Path(self.config_path).exists():
                self.send_response(404)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Config file not found'}).encode('utf-8'))
                return

            # Read the request body
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self.send_response(400)
                self.send_header('Content-type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json.dumps({'error': 'Empty request body'}).encode('utf-8'))
                return

            body = self.rfile.read(content_length)
            updates = json.loads(body.decode('utf-8'))

            # Read current config
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)

            # Apply updates (deep merge)
            def deep_update(base, updates):
                for key, value in updates.items():
                    if isinstance(value, dict) and key in base and isinstance(base[key], dict):
                        deep_update(base[key], value)
                    else:
                        base[key] = value

            deep_update(config_data, updates)

            # Write back to config file (with backup)
            backup_path = self.config_path + '.backup'
            import shutil
            shutil.copy2(self.config_path, backup_path)

            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=2)
                f.write('\n')  # Add trailing newline

            self.send_response(200)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({
                'success': True,
                'message': 'Configuration updated. Restart memo-rf for changes to take effect.',
                'backup': backup_path
            }).encode('utf-8'))

        except json.JSONDecodeError as e:
            self.send_response(400)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'error': f'Invalid JSON: {str(e)}'}).encode('utf-8'))

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.end_headers()
            self.wfile.write(json.dumps({'error': str(e)}).encode('utf-8'))

    def log_message(self, format, *args):
        """Custom log format."""
        sys.stderr.write(f"[{self.log_date_time_string()}] {format % args}\n")


def main():
    """Run the feed server."""
    parser = argparse.ArgumentParser(description='Memo-RF Feed Server')
    parser.add_argument('--port', type=int, default=5050,
                        help='Port to listen on (default: 5050)')
    parser.add_argument('--host', default='0.0.0.0',
                        help='Host to bind to (default: 0.0.0.0)')
    parser.add_argument('--sessions-dir', default=None,
                        help='Path to sessions directory (default: ./sessions or $MEMO_RF_SESSION_DIR)')
    parser.add_argument('--config-path', default=None,
                        help='Path to config.json (default: ./config/config.json)')

    args = parser.parse_args()

    # Resolve sessions directory
    if args.sessions_dir:
        sessions_dir = args.sessions_dir
    else:
        sessions_dir = os.environ.get('MEMO_RF_SESSION_DIR', 'sessions')

    # Make absolute path relative to current working directory
    sessions_dir = os.path.abspath(sessions_dir)

    # Resolve config path and directory
    if args.config_path:
        config_path = args.config_path
    else:
        config_path = os.path.join(os.getcwd(), 'config', 'config.json')

    config_path = os.path.abspath(config_path)
    config_dir = os.path.dirname(config_path)

    # Set paths for the handler
    FeedHandler.sessions_dir = sessions_dir
    FeedHandler.config_path = config_path
    FeedHandler.config_dir = config_dir

    # Create server
    server_address = (args.host, args.port)
    httpd = HTTPServer(server_address, FeedHandler)

    print(f"Memo-RF Feed Server running on http://{args.host}:{args.port}")
    print(f"Sessions directory: {sessions_dir}")
    print(f"Config file: {config_path}")
    print(f"Access from this device: http://localhost:{args.port}")

    # Try to show LAN IP for remote access
    try:
        import socket
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
        if local_ip and not local_ip.startswith('127.'):
            print(f"Access from network: http://{local_ip}:{args.port}")
    except:
        pass

    print("\nPress Ctrl+C to stop")

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down server...")
        httpd.shutdown()


if __name__ == '__main__':
    main()
